# Copilot / AI Agent Instructions — GCD (Golf Cart Display)

This file gives concise, actionable instructions for AI coding agents working in this repository. Keep changes minimal, consistent with constraints in the repo, and always prefer edits in the designated places.

1) Project summary
- ESP32 CYD 2432S028R touchscreen display integrating GPS, Meshtastic mesh radio, and ESP-NOW.
- UI uses EEZ Studio Flow exported to LVGL, UI code in `src/ui_eez/` (auto-generated).
- FreeRTOS tasks coordinate GPS, GUI, Meshtastic, ESP-NOW, EEPROM, and system services.

2) Quick dev & build commands
- Build (default env): `pio run` (env `gcd`), `pio run --target upload` to upload, `pio device monitor` to view debug via Serial
- PlatformIO envs noted in `platformio.ini` (`gcd`, `demo`, `calibration`)
- Monitor & upload ports: default `monitor_port` and `upload_port` are set in `platformio.ini` (COM12 in repo)
- Note: build scripts run pre/post and affect project files: `scripts/copy_cyd_configs.py`, `scripts/fix_lv_dropdown_set_selected.py`, `scripts/autoincrement.py`.

3) Where to make code changes
- Business logic: `src/*` (tasks, communication, hardware, storage)
- UI data binding & changes (not the generated UI): `src/get_set_vars.h/cpp` and `src/ui_eez/*` for generated code
- Inter-device protocol and radio: `src/communication/*` — add protocol handlers here
- Meshtastic customizations: edit `lib/meshtastic_customizations/esp32_overrides/`. Do NOT edit `lib/meshtastic-arduino_src/` directly.

4) Critical constraints & conventions
- Memory: limited flash + 320KB RAM. Avoid adding large libraries and minimize constant strings.
- UART0 split: GPS receives on UART0 Rx (pin 3), debug log on UART0 Tx (pin 1). Do NOT use UART0 as full-duplex.
- Meshtastic: Implement ESP32-specific code in `lib/meshtastic_customizations`. Keep `lib/meshtastic-arduino_src/` pristine for updates.
- Use `queuePreferenceWrite(key, ...)` to persist preferences and keep NVS keys ≤ 15 characters.
- EEZ Studio UI: treat UI as generated — change behavior via `get_set_vars.*` and related handlers, not by hand-editing generated flows.

5) Concurrency & synchronization
- Use global mutexes for shared resources defined in `src/globals.h`: `gpsMutex`, `eepromMutex`, `displayMutex`, `hotPacketMutex`.
- Use queues for asynchronous data flows: `eepromWriteQueue`, `meshtasticCallbackQueue`, `espnowRecvQueue`, `gpsConfigCallbackQueue`.
- Double buffer pattern for hot packet data: check `hotPacketActiveBuffer` and use `hotPacketBuffer_*` swapping under `hotPacketMutex`.
- Follow existing locking: `if (xSemaphoreTake(mutex, pdMS_TO_TICKS(100)) == pdTRUE) { ... xSemaphoreGive(mutex); }`.

6) Inter-component integration patterns
- Tasks created in `src/tasks/tasks.cpp`. Priorities & stack sizes defined in `src/config.h`.
- GPS parsing: `src/tasks/gps_task.cpp` uses NeoGPS with `gpsSerial` (UART0 Rx) and `gpsMutex` to protect shared state.
- GUI: `src/tasks/gui_task.cpp` runs LVGL and reads state under `gpsMutex` and `displayMutex` where appropriate.
- EEPROM: NVS Preferences are handled via `src/storage/preferences_manager.*` and are written using `queuePreferenceWrite` and processed by `eeprom_task`.

7) Meshtastic updates
- To update Meshtastic protobufs or upstream code: use `lib/meshtastic_customizations/update_scripts/update_meshtastic.py`. This script preserves ESP32 overrides and backs up upstream.
- DO NOT directly edit or commit changes to `lib/meshtastic-arduino_src/` unless they are generated by the update script.

8) UI variable pattern (EEZ & LVGL)
- All UI-bound getter/setters in `src/get_set_vars.h/cpp` — add new variables here and call `queuePreferenceWrite()` if the change is persistent.
- EEZ UI code references `get_var_*` and `set_var_*` functions. Example: `get_var_espnow_gci_mac_addr()` and `set_var_espnow_gci_mac_addr(const char*)`.

9) Debugging & Safe Edits
- Prefer using `Serial.println()` for debugging — debug TX uses UART0 TX; monitor via platformio `pio device monitor`.
- When touching code interacting with interrupts/wifi, keep core assignment in `tasks.cpp` in mind; WiFi operations run on core 0.

10) Useful files and locations
- `src/`: primary project code (tasks, comms, storage, hardware, UI)
- `src/config.h`: central config (pins, task sizes, priorities)
- `src/globals.h`: shared handles, mutexes, queues, double buffer vars
- `platformio.ini`: build & environment settings
- `NECESSARY TEMPLATE FILES/`: `lv_conf.h` and `User_Setup.h` copied by build script (do not edit the lib/library versions)
- `lib/meshtastic_customizations/`: ESP32-specific customizations and update scripts

11) Testing & running
- There are no automated unit tests in the repo; use `pio run` and serial monitor to diagnose.
- For UI calibration/debugging, use `env:calibration` to build the calibration-only firmware.

12) Always do this before merging or substantial PRs
- Confirm build compiles using `pio run` in `gcd` env
- Ensure modifications don't increase flash or heap beyond acceptable levels — watch `ESP.getFreeHeap()` and remove large static strings
- Run manual validation on hardware (if available): serial monitor, WiFi/Meshtastic functions, and task stability

If anything is unclear or there are missing details you want included, please tell me what you’d like changed or what areas I should expand. Thank you!